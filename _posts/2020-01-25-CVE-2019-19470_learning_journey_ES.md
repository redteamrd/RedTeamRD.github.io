---
title: Mi aprendizaje para escribir el exploit del CVE-2019-19470
classes: wide
---

Hola!, intentaré contarte mi historia sobre cómo reproduje el CVE-2019-19470, será tanto un aprendizaje personal como ejemplos técnicos, pero no pretende ser un tutorial, si deseas una revisión más técnica, puedes revisar la [publicación original](https://codewhitesec.blogspot.com/2020/01/cve-2019-19470-rumble-in-pipe.html)

Todos los créditos de este PoC van a [@frycos](https://twitter.com/frycos) y [@codewhitesec](https://twitter.com/codewhitesec) por descubrir el error y la explicación en su [blog](https://codewhitesec.blogspot.com/2020/01/cve-2019-19470-rumble-in-pipe.html).

# Empecemos...

Así es como comencé ... Un día en Twitter estaba buscando cosas relacionadas con los errores de escalada de privilegios de "sencillos" y me encontré este tweet de James Forshaw, que estaba comentando sobre una escalación de privilegios publicada por [@frycos](https://twitter.com/frycos) de [@codewhitesec](https://twitter.com/codewhitesec) [https://codewhitesec.blogspot.com/2020/01/cve-2019-19470-rumble-in-pipe.html](https://codewhitesec.blogspot.com/2020/01/cve-2019-19470-rumble-in-pipe.html) y decidí leerlo.

Después de leer el artículo, tuve algunas ideas sobre cómo funcionan algunas cosas y estaba familiarizado con la mayoría del contenido compartido. La mejor parte de este artículo es que no publicaron el PoC, así que decidí replicarlo y crear mi propia prueba de concepto.

# Resumen de CVE

Para darle una idea sobre esta vulnerabilidad, básicamente Tyniwall.exe es una aplicación de firewall que se ejecuta como SYSTEM, tiene una interfaz Namedpipe que está destinada a comunicarse solo con el proceso de Tyniwall, el error ocurre debido a un ataque de deserialización,  donde es posible serializar un comando a ejecutar y enviarlo a través de Namedpipe falsificando el nombre del proceso para obtener la ejecución del comando como SYSTEM.

# El proceso para replicar el exploit.

Leí varias veces el articulo y decidí trabajar cada pieza por separado. Mencionaré cada una de ellas y explicaré el enfoque que tomé para aprender cómo funcionan.

Nota: El orden de este blog no es necesariamente el orden en que hice las cosas, o cómo las fui aprendiendo, en la práctica digamos que empecé con Namedpipes, pero al no funcionar algunas cosas, salté a dnSpy, regrese a Namedpipes, leí e investigue de PEB y deserialización, etc.  Fue una investigación desordenada, en este post intentaré comentarles de mi aprendizaje en cada etapa. 

# Namedpipes

He escuchado, tal vez jugado un poco con Namedpipes, pero creo que necesitaba leer e investigar un poco más al respecto, por lo que mi enfoque fue hacer 2 cosas:
1. Lea sobre Namedpipes, cómo son y cómo funcionan, por qué las personas lo usan.
2. Investigar errores relacionados con Namedpipes, documentos, videos, blogs, etc.

Básicamente, Namedpipes proporcionan comunicación entre procesos, un proceso que actúa como servidor y otro como cliente. Para más información ir [aquí](https://docs.microsoft.com/en-us/dotnet/standard/io/how-to-use-named-pipes-for-network-interprocess-communication) .

Entonces, después de leer algunos artículos relacionados con namedpipes, cree una aplicación básica de servidor / cliente en C # para ver que funcionan, en la aplicación el servidor tenía un archivo disponible, cuando el cliente se conecta toma el archivo y lo copia en un directorio. El código está disponible [aquí](https://github.com/juliourena/plaintext/tree/master/CVE-PoC/CVE-2019-19470/NamedPipes-ExampleCode)

![namedpipes-file-transf](/assets/images/namedpipes-file-transf.gif)

Entendiendo mejor como funciona Namedpipe y la comunicación entre procesos, traté de replicar el mismo método de deserialización que utiliza Tinywall y ejecutar el código de una aplicación (Namedpipe Server) a la otra (Namedpipe Client) y lo hice usando el ejemplo que @frycos proporciona en su publicación para ejecutar una calculadora. 

![namedpipes-pop-calc](/assets/images/namedpipes-pop-calc.gif)

Parece super fácil todo lo que he puesto hasta ahora, pero la verdad no salió fácilmente, en este proceso, leí bastante e intenté cosas que no funcionaron, también descargue  [IO Ninja](https://ioninja.com/downloads.html), una herramienta que permite hacer sniffing de Namedpipes entre otras cosas, está la descubrí que cuando veía un video de Gil Cohen discutiendo sobre Namedpipe, y cómo abusar de él en sus charlas de [Defcon](https://www.youtube.com/watch?v=6xt0lEj-sac) y [HIP17](https://www.youtube.com/watch?v=m6zISgWPGGY) 
 
# Deserialización

El punto de partida para la investigación fue [ysoserial.net](https://github.com/pwntester/ysoserial.net), es una colección de utilidades descubiertas en librerías comunes de .NET que pueden, en las condiciones adecuadas, explotar aplicaciones .NET para que realicen deserialización insegura de objetos. 

Mientras investigaba sobre la deserialización, vi 2 o 3 videos de Álvaro Muñoz [@pwntester](https://twitter.com/pwntester), autor de ysoserial.net y leí algunas de sus investigaciones y errores que encontró, no guardé todos los enlaces de lo que leí sobre él, pero puedes ver este video que me encantó:

[Atacando la deserialización de .NET - Álvaro Muñoz](https://www.youtube.com/watch?v=eDfGpu3iE4Q)

¡Alvaro también agregó a su herramienta la utilidad TypeConfuseDelegate de James Forshaw [tiraniddo](https://twitter.com/tiraniddo), que es como el padre de la escalada de privilegios debido a que algunas de sus investigaciones y herramientas han abierto las puertas a más investigadores para encontrar errores basados ​​en sus trabajos! Gracias por su increíble investigación, libros, videos, etc.

Ysoserial.net, como menciona Álvaro, fue inspirado en el proyecto ysoserial de [Chris Frohoff](https://github.com/frohoff/ysoserial), la versión para java. Si quisieras entender un poco mejor como utilizarlo antes de continuar, puedes ver  cómo lo utilizo para explotar [Arkham de HTB](https://youtu.be/cZfuwuJFa60?t=2345).

# dnSpy

dnSpy nos permite descompilar código .NET y extraer el código fuente, incluso establecer sus puntos de interrupción (breakpoints), modificar variables en tiempo real, etc., una herramienta realmente sorprendente [dnsSpy](https://github.com/0xd4d/dnSpy).

[@frycos](https://twitter.com/frycos) señala en el post: "Now, we created a malicious object with ysoserial.NET and   Forshaw's TypeConfuseDelegate gadget to pop a calc process. In the debugger, we use System.Convert.FromBase64String("...") as expression to replace the current value " 

Mi punto aquí fue el siguiente, comprendo que hace esta función (System.Convert.FromBase64String), pero ¿cómo puedo usar eso en dnSpy? Reí a carcajadas cuando descubrí lo que necesito hacer, básicamente fue copiar y pegar el text tal como él mencionó y dnSpy hará el resto, verás el gif para que puedas entender de lo que estoy hablando: D

El que no sabe, es como el que no ve. 

![dnSpy-base64](/assets/images/dnSpy-base64.gif)

# PEB - Bloque de entorno de proceso

La parte final de la ecuación era el PEB. El PEB es una estructura de datos que las aplicaciones pueden usar para obtener información de un proceso, como la lista de módulos cargados, argumentos de inicio, dirección de imagen, valores de línea de comando, etc.

[WinDbg](http://www.windbg.org/)  es una herramienta que puede utilizar para inspeccionar el PEB, por ejemplo. Habia utilizado WinDbg para tratar de comprender temas como AMSI, Process Hollowing, etc., al menos tenía una idea de cómo usarlo. Para este punto, mi enfoque fue entender cómo modificar el PEB manualmente y luego hacerlo programáticamente, así que instalé [WinDbg](http://www.windbg.org/) y seguí la publicación de [@spotless](https://twitter.com/spotheplanet) sobre cómo hacerlo, puedes encontrarla [aquí](https://ired.team/offensive-security/defense-evasion/masquerading-processes-in-userland-through-_peb)

![windbg](/assets/images/windbg.gif)

# Codigo C# para modificar el PEB

Después de terminar de entender lo que tenía que hacer con el PEB, era necesario automatizar el proceso en C#, afortunadamente, no encontré ningún código C# que hiciera manipulación de PEB, la única referencia que tuve fue el script de PowerShell de [FuzzySec](https://twitter.com/FuzzySec) que menciona [@frycos](https://twitter.com/frycos) en el artículo [Masquerade-PEB.ps1](https://github.com/FuzzySecurity/PowerShell-Suite/blob/master/Masquerade-PEB.ps1).

Mi primera idea fue buscar la forma de convertir, el código a C#, busque algunas herramientas, guías y demás, pero no logré hacerlo, trataba de simplificar el proceso de replicación, pero para mi suerte no pude. Observando el código de Masquerade-PEB, me pareció muy complejo para replicar, pero de todas formas lo intenté y podría decir que de todo lo que hice, esta fue la parte que más disfruté y de la que más aprendí.

La belleza de este proceso de replicación es que me ayudó a comprender mejor cómo funciona todo, las clases, las llamadas de la API, los cálculos para obtener las ubicaciones de los parámetros del PEB, todo comenzó a tener sentido a medida que avanzaba y después de algunas pruebas y errores, leyendo aquí y allá, pude crear mi propia versión de [Masquerade-PEB en C#](https://github.com/juliourena/plaintext/tree/master/CSharp%20Tools/Masquerade-PEB)

![modify-peb](/assets/images/modify-peb.jpg)

![success-gif-9](/assets/images/success-gif-9.gif)

Nota: cuando twitteé lo que hice, [@Cn33liz](https://twitter.com/Cneelis) me señaló que lo hizo hace 2 años con el proyecto [p0wnedShell](https://github.com /Cn33liz/p0wnedShell/blob/master/p0wnedShell/Opsec/p0wnedMasq.cs) también fue amable al señalarme [este enlace](https://www.osronline.com/article.cfm%5Earticle=499.htm) para ayudarme a entender cómo una pieza del código funciona.

# Ejecución del Exploit

¡Con todas las piezas del rompecabezas solo necesitaba poner cada una en su lugar, así que lo hice! 

El PoC para el CVE-2019-19470 podrás encontrarlo [aquí](https://github.com/juliourena/plaintext/tree/master/CVE-PoC/CVE-2019-19470). 

{% include video id="TFhDXyFdTHs" provider="youtube" %}

**Dios les bendiga!**

**El servir a Cristo, no es una tarea, sino una relación. Amigos de Dios. Jn 15:15** 
